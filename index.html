<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Civilization I - Tech Planner</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
      :root {
        --bg: #0f172a;
        --surface: #1e293b;
        --text: #f1f5f9;
        --muted: #64748b;
        --accent: #38bdf8;
        --success: #34d399;
        --warning: #fbbf24;
        --error: #f87171;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: var(--bg);
        color: var(--text);
        line-height: 1.6;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 40px;
      }

      .header h1 {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 8px;
        background: linear-gradient(135deg, var(--accent), #818cf8);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .header p {
        font-size: 1.1rem;
        color: var(--muted);
        max-width: 600px;
        margin: 0 auto;
      }

      .main-content {
        display: grid;
        grid-template-columns: 1fr 2fr;
        gap: 30px;
        margin-bottom: 30px;
      }

      .targets-panel {
        background: var(--surface);
        border-radius: 16px;
        padding: 24px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .targets-panel h2 {
        font-size: 1.5rem;
        margin-bottom: 20px;
        color: var(--accent);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .targets-panel h2::before {
        content: "üéØ";
        font-size: 1.2rem;
      }

      .add-target-section {
        margin-bottom: 24px;
      }

      .add-target-btn {
        width: 100%;
        padding: 16px;
        background: linear-gradient(135deg, var(--accent), #818cf8);
        border: none;
        border-radius: 12px;
        color: white;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .add-target-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(56, 189, 248, 0.3);
      }

      .add-target-btn::before {
        content: "+";
        font-size: 1.5rem;
        font-weight: 300;
      }

      .target-pills {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 16px;
      }

      .target-pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: rgba(56, 189, 248, 0.1);
        border: 1px solid rgba(56, 189, 248, 0.3);
        border-radius: 20px;
        font-size: 0.9rem;
        color: var(--accent);
        font-weight: 500;
      }

      .target-pill .remove-btn {
        background: none;
        border: none;
        color: var(--accent);
        cursor: pointer;
        font-size: 1.2rem;
        padding: 0;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background 0.2s;
      }

      .target-pill .remove-btn:hover {
        background: rgba(56, 189, 248, 0.2);
      }

      .target-summary {
        padding: 12px;
        background: rgba(56, 189, 248, 0.05);
        border-radius: 8px;
        font-size: 0.9rem;
        color: var(--muted);
        text-align: center;
      }

      .research-panel {
        background: var(--surface);
        border-radius: 16px;
        padding: 24px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .research-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .research-header h2 {
        font-size: 1.5rem;
        color: var(--accent);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .research-header h2::before {
        content: "üìã";
        font-size: 1.2rem;
      }

      .research-actions {
        display: flex;
        gap: 12px;
      }

      .btn {
        padding: 8px 16px;
        border: 1px solid var(--muted);
        background: transparent;
        color: var(--muted);
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
      }

      .btn:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .btn.primary {
        background: var(--accent);
        border-color: var(--accent);
        color: white;
      }

      .btn.primary:hover {
        background: #0ea5e9;
      }

      .research-list {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        padding: 16px;
        min-height: 200px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .research-list.empty {
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--muted);
        font-style: italic;
      }

      .research-list ol {
        list-style: none;
        counter-reset: tech-counter;
      }

      .research-list li {
        counter-increment: tech-counter;
        padding: 12px 16px;
        margin-bottom: 8px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        cursor: grab;
        transition: all 0.2s;
        position: relative;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .research-list li::before {
        content: counter(tech-counter);
        background: var(--accent);
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        font-weight: 600;
        flex-shrink: 0;
      }

      .research-list li:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.1);
        transform: translateY(-1px);
      }

      .research-list li.target {
        background: rgba(56, 189, 248, 0.1);
        border-color: rgba(56, 189, 248, 0.3);
      }

      .research-list li.target::before {
        background: var(--accent);
      }

      .tech-name {
        font-weight: 600;
        flex: 1;
      }

      .tech-name.target {
        color: var(--accent);
      }

      .tech-allows {
        display: flex;
        gap: 4px;
        flex-wrap: wrap;
      }

      .allows-chip {
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.7rem;
        font-weight: 500;
      }

      .allows-unit {
        background: rgba(34, 197, 94, 0.2);
        color: #4ade80;
      }

      .allows-building {
        background: rgba(59, 130, 246, 0.2);
        color: #60a5fa;
      }

      .allows-wonder {
        background: rgba(168, 85, 247, 0.2);
        color: #a78bfa;
      }

      .allows-other {
        background: rgba(251, 191, 36, 0.2);
        color: #fbbf24;
      }

      .validation-status {
        margin-top: 16px;
        padding: 12px;
        border-radius: 8px;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .validation-status.valid {
        background: rgba(34, 197, 94, 0.1);
        border: 1px solid rgba(34, 197, 94, 0.3);
        color: #4ade80;
      }

      .validation-status.warning {
        background: rgba(251, 191, 36, 0.1);
        border: 1px solid rgba(251, 191, 36, 0.3);
        color: #fbbf24;
      }

      .saved-plans {
        background: var(--surface);
        border-radius: 16px;
        padding: 24px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .saved-plans h2 {
        font-size: 1.5rem;
        margin-bottom: 20px;
        color: var(--accent);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .saved-plans h2::before {
        content: "üíæ";
        font-size: 1.2rem;
      }

      .save-section {
        display: flex;
        gap: 12px;
        margin-bottom: 20px;
      }

      .save-input {
        flex: 1;
        padding: 12px 16px;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        color: var(--text);
        font-size: 0.9rem;
      }

      .save-input:focus {
        outline: none;
        border-color: var(--accent);
      }

      .saved-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .saved-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        transition: all 0.2s;
      }

      .saved-item:hover {
        background: rgba(0, 0, 0, 0.3);
        border-color: rgba(255, 255, 255, 0.1);
      }

      .saved-item-info {
        flex: 1;
      }

      .saved-item-name {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .saved-item-details {
        font-size: 0.8rem;
        color: var(--muted);
      }

      .saved-item-actions {
        display: flex;
        gap: 8px;
      }

      .btn-small {
        padding: 6px 12px;
        border: 1px solid var(--muted);
        background: transparent;
        color: var(--muted);
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.8rem;
        transition: all 0.2s;
      }

      .btn-small:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .btn-small.danger:hover {
        border-color: var(--error);
        color: var(--error);
      }

      .dropdown {
        position: absolute;
        background: var(--surface);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 16px;
        width: 300px;
        max-height: 400px;
        z-index: 1000;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
      }

      .dropdown-search {
        width: 100%;
        padding: 12px;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        color: var(--text);
        font-size: 0.9rem;
        margin-bottom: 12px;
      }

      .dropdown-search:focus {
        outline: none;
        border-color: var(--accent);
      }

      .dropdown-options {
        max-height: 250px;
        overflow-y: auto;
      }

      .dropdown-option {
        padding: 10px 12px;
        cursor: pointer;
        border-radius: 6px;
        transition: background 0.2s;
        font-size: 0.9rem;
      }

      .dropdown-option:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .sortable-ghost {
        opacity: 0.5;
        background: rgba(56, 189, 248, 0.1) !important;
      }

      .sortable-chosen {
        background: rgba(56, 189, 248, 0.2) !important;
        border-color: var(--accent) !important;
      }

      @media (max-width: 768px) {
        .main-content {
          grid-template-columns: 1fr;
          gap: 20px;
        }

        .header h1 {
          font-size: 2rem;
        }

        .research-actions {
          flex-direction: column;
        }

        .save-section {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Civilization I Tech Planner</h1>
        <p>Plan your technology research path by selecting targets and optimizing the order</p>
      </div>

      <div class="main-content">
        <div class="targets-panel">
          <h2>Research Targets</h2>

          <div class="add-target-section">
            <button class="add-target-btn" onclick="showAddTargetDropdown()">Add Technology Target</button>
          </div>

          <div class="target-pills" id="targetPills">
            <!-- Target pills will appear here -->
          </div>

          <div class="target-summary" id="targetSummary">No targets selected</div>
        </div>

        <div class="research-panel">
          <div class="research-header">
            <h2>Research Order</h2>
            <div class="research-actions">
              <button class="btn" onclick="clearAll()">Clear</button>
              <button class="btn primary" onclick="scrollToSaveAndFocus()">Save Plan</button>
            </div>
          </div>

          <div class="research-list" id="chain">
            <div class="empty">Add technology targets to see your research path</div>
          </div>

          <div class="validation-status" id="notes" style="display: none">
            <!-- Validation status will appear here -->
          </div>
        </div>
      </div>

      <div class="saved-plans">
        <h2>Saved Plans</h2>

        <div class="save-section">
          <input type="text" class="save-input" id="saveNameInput" placeholder="Enter plan name..." />
          <button class="btn primary" onclick="saveCurrentList()">Save</button>
        </div>

        <div class="saved-list" id="savedLists">
          <!-- Saved plans will appear here -->
        </div>
      </div>
    </div>

    <!-- Add Target Dropdown -->
    <div id="addTargetDropdown" class="dropdown" style="display: none">
      <!-- Dropdown content will be populated here -->
    </div>

    <script>
      // --- Global state for multiple targets ---
      let selectedTargets = new Set();

      // --- Unified data structure: tech -> { prereqs: [], allows: {} } ---
      // Source: Civilization Wiki - https://civilization.fandom.com/wiki/List_of_advances_in_Civ1
      const advances = {
        "Advanced Flight": {
          prereqs: ["Flight", "Electricity"],
          allows: { units: ["Bomber", "Carrier"] },
        },
        Alphabet: {
          prereqs: [],
          allows: {},
        },
        Astronomy: {
          prereqs: ["Mysticism", "Mathematics"],
          allows: { wonders: ["Copernicus' Observatory"] },
        },
        "Atomic Theory": {
          prereqs: ["Theory of Gravity", "Physics"],
          allows: {},
        },
        Automobile: {
          prereqs: ["Combustion", "Steel"],
          allows: { units: ["Armor"] },
        },
        Banking: {
          prereqs: ["Trade", "The Republic"],
          allows: { buildings: ["Bank"] },
        },
        "Bridge Building": {
          prereqs: ["Iron Working", "Alphabet"],
          allows: { other: ["Road on river squares"] },
        },
        "Bronze Working": {
          prereqs: [],
          allows: { units: ["Phalanx"], wonders: ["Colossus"] },
        },
        "Ceremonial Burial": {
          prereqs: [],
          allows: { buildings: ["Temple"] },
        },
        Chemistry: {
          prereqs: ["University", "Medicine"],
          allows: {},
        },
        Chivalry: {
          prereqs: ["Feudalism", "Horseback Riding"],
          allows: { units: ["Knights"] },
        },
        "Code of Laws": {
          prereqs: ["Alphabet"],
          allows: { buildings: ["Courthouse"] },
        },
        Combustion: {
          prereqs: ["Refining", "Explosives"],
          allows: { units: ["Cruiser"] },
        },
        Communism: {
          prereqs: ["Philosophy", "Industrialization"],
          allows: { other: ["Communism"], wonders: ["United Nations"] },
        },
        Computers: {
          prereqs: ["Mathematics", "Electronics"],
          allows: { wonders: ["SETI Program"] },
        },
        Conscription: {
          prereqs: ["The Republic", "Explosives"],
          allows: { units: ["Riflemen"] },
        },
        Construction: {
          prereqs: ["Masonry", "Currency"],
          allows: { other: ["Fortress"], buildings: ["Aqueduct", "Colosseum"] },
        },
        "The Corporation": {
          prereqs: ["Banking", "Industrialization"],
          allows: {},
        },
        Currency: {
          prereqs: ["Bronze Working"],
          allows: { buildings: ["Marketplace"] },
        },
        Democracy: {
          prereqs: ["Philosophy", "Literacy"],
          allows: { other: ["Democracy"] },
        },
        Electricity: {
          prereqs: ["Magnetism", "Metallurgy"],
          allows: {},
        },
        Electronics: {
          prereqs: ["Electricity", "Engineering"],
          allows: { buildings: ["Hydro Plant"], wonders: ["Hoover Dam"] },
        },
        Engineering: {
          prereqs: ["The Wheel", "Construction"],
          allows: {},
        },
        Explosives: {
          prereqs: ["Gunpowder", "Chemistry"],
          allows: {},
        },
        Feudalism: {
          prereqs: ["Masonry", "Monarchy"],
          allows: {},
        },
        Flight: {
          prereqs: ["Combustion", "Physics"],
          allows: { units: ["Fighter"] },
        },
        "Fusion Power": {
          prereqs: ["Nuclear Power", "Superconductor"],
          allows: {},
        },
        "Future Tech": {
          prereqs: ["Fusion Power"],
          allows: {},
        },
        "Genetic Engineering": {
          prereqs: ["Medicine", "The Corporation"],
          allows: { wonders: ["Cure for Cancer"] },
        },
        Gunpowder: {
          prereqs: ["Invention", "Iron Working"],
          allows: { units: ["Musketeers"] },
        },
        "Horseback Riding": {
          prereqs: [],
          allows: { units: ["Cavalry"] },
        },
        Industrialization: {
          prereqs: ["Railroad", "Banking"],
          allows: { units: ["Transport"], buildings: ["Factory"], wonders: ["Women's Suffrage"] },
        },
        Invention: {
          prereqs: ["Engineering", "Literacy"],
          allows: {},
        },
        "Iron Working": {
          prereqs: ["Bronze Working"],
          allows: { units: ["Legion"] },
        },
        "Labor Union": {
          prereqs: ["Mass Production", "Communism"],
          allows: { units: ["Mech. Inf."] },
        },
        Literacy: {
          prereqs: ["Writing", "Code of Laws"],
          allows: { wonders: ["Great Library"] },
        },
        Magnetism: {
          prereqs: ["Navigation", "Physics"],
          allows: { units: ["Frigate"] },
        },
        Mapmaking: {
          prereqs: ["Alphabet"],
          allows: { wonders: ["Lighthouse"], units: ["Trireme"] },
        },
        Masonry: {
          prereqs: [],
          allows: { buildings: ["City Walls", "Palace"], wonders: ["Pyramids", "Great Wall"] },
        },
        "Mass Production": {
          prereqs: ["Automobile", "The Corporation"],
          allows: { units: ["Submarine"], buildings: ["Mass Transit"] },
        },
        Mathematics: {
          prereqs: ["Alphabet", "Masonry"],
          allows: { units: ["Catapult"] },
        },
        Medicine: {
          prereqs: ["Philosophy", "Trade"],
          allows: { wonders: ["Shakespeare's Theatre"] },
        },
        Metallurgy: {
          prereqs: ["Gunpowder", "University"],
          allows: { units: ["Cannon"] },
        },
        Monarchy: {
          prereqs: ["Ceremonial Burial", "Code of Laws"],
          allows: { other: ["Monarchy"] },
        },
        Mysticism: {
          prereqs: ["Ceremonial Burial"],
          allows: { wonders: ["Oracle"] },
        },
        Navigation: {
          prereqs: ["Mapmaking", "Astronomy"],
          allows: { wonders: ["Magellan's Expedition"], units: ["Sail"] },
        },
        "Nuclear Fission": {
          prereqs: ["Mass Production", "Atomic Theory"],
          allows: { wonders: ["Manhattan Project"] },
        },
        "Nuclear Power": {
          prereqs: ["Nuclear Fission", "Electronics"],
          allows: { buildings: ["Nuclear Plant"] },
        },
        Philosophy: {
          prereqs: ["Mysticism", "Literacy"],
          allows: {},
        },
        Physics: {
          prereqs: ["Mathematics", "Navigation"],
          allows: {},
        },
        Plastics: {
          prereqs: ["Refining", "Space Flight"],
          allows: { wonders: ["SS Component"] },
        },
        Pottery: {
          prereqs: [],
          allows: { buildings: ["Granary"], wonders: ["Hanging Gardens"] },
        },
        Railroad: {
          prereqs: ["Steam Engine", "Bridge Building"],
          allows: { other: ["RailRoad on road squares"], wonders: ["Darwin's Voyage"] },
        },
        Recycling: {
          prereqs: ["Mass Production", "Democracy"],
          allows: { buildings: ["Recycling Center"] },
        },
        Refining: {
          prereqs: ["Chemistry", "The Corporation"],
          allows: { buildings: ["Power Plant"] },
        },
        Religion: {
          prereqs: ["Philosophy", "Writing"],
          allows: { wonders: ["Michelangelo's Chapel", "J.S. Bach's Cathedral"], buildings: ["Cathedral"] },
        },
        "The Republic": {
          prereqs: ["Code of Laws", "Literacy"],
          allows: { other: ["Republic"] },
        },
        Robotics: {
          prereqs: ["Plastics", "Computers"],
          allows: { units: ["Artillery"], buildings: ["Mfg. Plant"], wonders: ["SS Module"] },
        },
        Rocketry: {
          prereqs: ["Advanced Flight", "Electronics"],
          allows: { units: ["Nuclear unit (with Manhattan Project)"] },
        },
        "Space Flight": {
          prereqs: ["Computers", "Rocketry"],
          allows: { wonders: ["Apollo Program", "SS Structural"] },
        },
        "Steam Engine": {
          prereqs: ["Physics", "Invention"],
          allows: { units: ["Ironclad"] },
        },
        Steel: {
          prereqs: ["Metallurgy", "Industrialization"],
          allows: { units: ["Battleship"] },
        },
        Superconductor: {
          prereqs: ["Plastics", "Mass Production"],
          allows: { buildings: ["SDI Defense"] },
        },
        "Theory of Gravity": {
          prereqs: ["Astronomy", "University"],
          allows: { wonders: ["Isaac Newton's College"] },
        },
        Trade: {
          prereqs: ["Currency", "Code of Laws"],
          allows: { units: ["Caravan"] },
        },
        University: {
          prereqs: ["Mathematics", "Philosophy"],
          allows: { buildings: ["University"] },
        },
        "The Wheel": {
          prereqs: [],
          allows: { units: ["Chariot"] },
        },
        Writing: {
          prereqs: ["Alphabet"],
          allows: { buildings: ["Library"], units: ["Diplomat"] },
        },
      };

      // Build an alphabetised list of techs
      const allTechs = Object.keys(advances).sort((a, b) => a.localeCompare(b));

      const chainEl = document.getElementById("chain");
      const summaryEl = document.getElementById("targetSummary");
      const notesEl = document.getElementById("notes");

      // Helper function to categorize an item
      function categorizeItem(item) {
        // Search through all advances to find which category this item belongs to
        for (const [techName, techData] of Object.entries(advances)) {
          const allows = techData.allows || {};
          for (const [category, items] of Object.entries(allows)) {
            if (Array.isArray(items) && items.includes(item)) {
              return category;
            }
          }
        }
        return "other";
      }

      // Helper function to get allows for a technology
      function getTechnologyAllows(tech) {
        const techAllows = advances[tech]?.allows || {};
        const categorized = { units: [], buildings: [], wonders: [], other: [] };

        // Process each category in the allows data
        Object.entries(techAllows).forEach(([category, items]) => {
          if (Array.isArray(items)) {
            items.forEach((item) => {
              const itemCategory = categorizeItem(item);
              if (!categorized[itemCategory].includes(item)) {
                categorized[itemCategory].push(item);
              }
            });
          }
        });

        return categorized;
      }

      // Depth-first search to gather prerequisites; returns in dependency order (prereqs first)
      function prerequisiteChain(target) {
        const seen = new Set();
        const order = [];
        function dfs(tech) {
          if (seen.has(tech)) return; // prevent cycles
          seen.add(tech);
          const reqs = advances[tech]?.prereqs || [];
          reqs.forEach(dfs); // ensure requirements come first
          order.push(tech);
        }
        // Build graph back from target; we don't include the target when reporting "needed" list
        const reqs = advances[target]?.prereqs || [];
        reqs.forEach(dfs);
        return order; // this contains only prerequisites, correctly ordered, no duplicates
      }

      function render() {
        // This function is no longer needed since we only use the multi-target system
        // The renderMultiTargetChain function handles all rendering now
      }

      function renderMultiTargetChain() {
        const chainEl = document.getElementById("chain");
        const summaryEl = document.getElementById("targetSummary");
        const notesEl = document.getElementById("notes");

        if (selectedTargets.size === 0) {
          summaryEl.textContent = "No targets selected";
          chainEl.innerHTML = '<div class="empty">Add technology targets to see your research path</div>';
          notesEl.style.display = "none";
          return;
        }

        // Check if there's a custom order to preserve
        // Don't use getCurrentOrder() here as it can create circular dependency
        const ol = chainEl.querySelector("ol");
        const existingItems = ol ? ol.querySelectorAll("li:not(.no-drag)") : [];
        const hasCustomOrder = existingItems.length > 0;

        let currentOrder = [];
        if (hasCustomOrder) {
          // Read the order directly from the DOM elements in their visual order
          currentOrder = Array.from(existingItems)
            .map((item) => item.dataset.techName)
            .filter((name) => name && advances[name]);

          console.log("Reading custom order from DOM:", currentOrder);
        }

        // Get combined prerequisites for all targets
        const combinedPrereqs = getCombinedPrerequisites();

        console.log("renderMultiTargetChain debug:", {
          selectedTargets: Array.from(selectedTargets),
          currentOrder,
          hasCustomOrder,
          combinedPrereqs,
          combinedPrereqsLength: combinedPrereqs.length,
        });

        // Update summary
        if (selectedTargets.size === 1) {
          summaryEl.textContent = `1 target ‚Ä¢ ${combinedPrereqs.length} prerequisites`;
        } else {
          summaryEl.textContent = `${selectedTargets.size} targets ‚Ä¢ ${combinedPrereqs.length} prerequisites`;
        }

        // Render the ordered list
        chainEl.innerHTML = "";
        if (!combinedPrereqs.length) {
          chainEl.innerHTML = '<div class="empty">Selected technologies have no prerequisites</div>';
        } else if (hasCustomOrder) {
          // Use the existing custom order, but ensure all prerequisites and targets are included
          const allTechsInOrder = [...currentOrder];

          // Add any missing prerequisites and targets
          const allRequiredTechs = [...combinedPrereqs, ...selectedTargets];
          allRequiredTechs.forEach((tech) => {
            if (!allTechsInOrder.includes(tech)) {
              allTechsInOrder.push(tech);
            }
          });

          const ol = document.createElement("ol");
          allTechsInOrder.forEach((tech) => {
            const li = document.createElement("li");

            // Check if this is a target technology
            const isTarget = selectedTargets.has(tech);
            if (isTarget) {
              li.classList.add("target");
            }

            // Add allows information with color coding
            const techAllows = getTechnologyAllows(tech);
            let allowsHtml = "";
            let allowsChips = [];

            Object.entries(techAllows).forEach(([category, items]) => {
              if (items.length > 0) {
                items.forEach((item) => {
                  const cssClass = category === "units" ? "unit" : category === "buildings" ? "building" : category === "wonders" ? "wonder" : "other";
                  allowsChips.push(`<span class="allows-chip allows-${cssClass}">${item}</span>`);
                });
              }
            });

            if (allowsChips.length > 0) {
              allowsHtml = `<div class="tech-allows">${allowsChips.join("")}</div>`;
            }

            const displayName = isTarget ? `‚Üí ${tech}` : tech;
            const className = isTarget ? "target" : "";

            li.innerHTML = `
              <div class="tech-name ${className}">${displayName}</div>
              ${allowsHtml}
            `;
            li.dataset.techName = tech;
            if (isTarget) {
              li.dataset.isTarget = "true";
            }
            ol.appendChild(li);
          });
          chainEl.appendChild(ol);
        } else {
          // Use default prerequisite order
          const ol = document.createElement("ol");

          combinedPrereqs.forEach((t, idx) => {
            const li = document.createElement("li");

            // Add allows information with color coding
            const techAllows = getTechnologyAllows(t);
            let allowsHtml = "";
            let allowsChips = [];

            Object.entries(techAllows).forEach(([category, items]) => {
              if (items.length > 0) {
                items.forEach((item) => {
                  const cssClass = category === "units" ? "unit" : category === "buildings" ? "building" : category === "wonders" ? "wonder" : "other";
                  allowsChips.push(`<span class="allows-chip allows-${cssClass}">${item}</span>`);
                });
              }
            });

            if (allowsChips.length > 0) {
              allowsHtml = `<div class="tech-allows">${allowsChips.join("")}</div>`;
            }

            li.innerHTML = `
              <div class="tech-name">${t}</div>
              ${allowsHtml}
            `;
            li.dataset.techName = t;
            ol.appendChild(li);
          });

          // Add target techs at the end
          selectedTargets.forEach((target) => {
            const li = document.createElement("li");
            li.classList.add("target");
            li.innerHTML = `
              <div class="tech-name target">‚Üí ${target}</div>
            `;
            li.dataset.techName = target;
            li.dataset.isTarget = "true";
            ol.appendChild(li);
          });

          chainEl.appendChild(ol);
        }

        // Initialize SortableJS after rendering
        initializeSortable();

        // Set initial validation status
        updateValidationStatus();
      }

      function getCombinedPrerequisites() {
        const allPrereqs = new Set();

        selectedTargets.forEach((target) => {
          const prereqs = prerequisiteChain(target);
          console.log(`Prerequisites for ${target}:`, prereqs);
          prereqs.forEach((prereq) => allPrereqs.add(prereq));
        });

        const result = Array.from(allPrereqs);
        console.log("Combined prerequisites:", result);
        return result;
      }

      function updateMultiTargetUI() {
        const pillsContainer = document.getElementById("targetPills");
        pillsContainer.innerHTML = "";

        selectedTargets.forEach((target) => {
          const pill = document.createElement("span");
          pill.className = "target-pill";

          pill.innerHTML = `
            ${target}
            <button class="remove-btn" onclick="removeTarget('${target}')">√ó</button>
          `;

          pillsContainer.appendChild(pill);
        });

        updateMultiTargetSummary();

        // Update validation status after UI changes
        setTimeout(() => {
          updateValidationStatus();
        }, 0);
      }

      function updateMultiTargetSummary() {
        const summaryEl = document.getElementById("targetSummary");
        const prereqCount = getCombinedPrerequisites().length;

        if (selectedTargets.size === 1) {
          const target = Array.from(selectedTargets)[0];
          summaryEl.textContent = `Prerequisites: ${prereqCount}`;
        } else {
          summaryEl.textContent = `Combined prerequisites: ${prereqCount} (from ${selectedTargets.size} targets)`;
        }
      }

      function showAddTargetDropdown() {
        const dropdown = document.getElementById("addTargetDropdown");
        const addBtn = document.querySelector(".add-target-btn");

        if (dropdown.style.display === "block") {
          dropdown.style.display = "none";
          return;
        }

        // Position the dropdown near the add button
        const btnRect = addBtn.getBoundingClientRect();
        dropdown.style.left = `${btnRect.left}px`;
        dropdown.style.top = `${btnRect.bottom + 8}px`;

        // Create dropdown content with search
        dropdown.innerHTML = `
          <input 
            id="targetSearchInput" 
            type="text" 
            placeholder="Search technologies..." 
            class="dropdown-search"
          />
          <div id="targetOptions" class="dropdown-options">
            <!-- Technology options will be populated here -->
          </div>
        `;

        // Get the options container
        const optionsContainer = dropdown.querySelector("#targetOptions");
        const searchInput = dropdown.querySelector("#targetSearchInput");

        // Function to populate options based on search
        function populateTargetOptions(searchTerm = "") {
          optionsContainer.innerHTML = "";
          const filteredTechs = Object.keys(advances).filter((tech) => {
            if (selectedTargets.has(tech)) return false;
            if (!searchTerm) return true;
            return tech.toLowerCase().includes(searchTerm.toLowerCase());
          });

          filteredTechs.forEach((tech) => {
            const option = document.createElement("div");
            option.className = "dropdown-option";
            option.textContent = tech;
            option.onclick = () => {
              selectedTargets.add(tech);
              updateMultiTargetUI();
              renderMultiTargetChain();
              dropdown.style.display = "none";
            };
            optionsContainer.appendChild(option);
          });
        }

        // Initial population
        populateTargetOptions();

        // Add search functionality
        searchInput.addEventListener("input", (e) => {
          populateTargetOptions(e.target.value);
        });

        // Focus the search input
        setTimeout(() => {
          searchInput.focus();
        }, 0);

        dropdown.style.display = "block";

        // Close dropdown when clicking outside
        setTimeout(() => {
          document.addEventListener("click", function closeDropdown(e) {
            if (!dropdown.contains(e.target) && !addBtn.contains(e.target)) {
              dropdown.style.display = "none";
              document.removeEventListener("click", closeDropdown);
            }
          });
        }, 0);
      }

      function removeTarget(target) {
        selectedTargets.delete(target);
        updateMultiTargetUI();
        renderMultiTargetChain();
      }

      // Save/Load functionality
      const STORAGE_KEY = "civ1_tech_lists";

      function getSavedLists() {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          return saved ? JSON.parse(saved) : {};
        } catch (e) {
          console.error("Error loading saved lists:", e);
          return {};
        }
      }

      function saveLists(lists) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(lists));
        } catch (e) {
          console.error("Error saving lists:", e);
        }
      }

      function saveCurrentListFromTop() {
        const nameInput = document.getElementById("saveNameInput");
        const name = nameInput.value.trim();

        if (!name) {
          alert("Please enter a name for your list");
          return;
        }

        if (selectedTargets.size === 0) {
          alert("Please select at least one technology first");
          return;
        }

        const combinedPrereqs = getCombinedPrerequisites();
        const customOrder = getCurrentOrder();
        const savedLists = getSavedLists();

        savedLists[name] = {
          targets: Array.from(selectedTargets),
          prerequisites: combinedPrereqs,
          customOrder: customOrder.length > 0 ? customOrder : null,
          timestamp: Date.now(),
        };

        saveLists(savedLists);
        nameInput.value = "";
        renderSavedLists();

        // Show success message
        const saveBtn = document.getElementById("saveBtnTop");
        const originalText = saveBtn.textContent;
        saveBtn.textContent = "Saved!";
        saveBtn.style.background = "#34d399";
        setTimeout(() => {
          saveBtn.textContent = originalText;
          saveBtn.style.background = "var(--accent)";
        }, 1500);
      }

      function deleteList(name) {
        if (confirm(`Delete "${name}"?`)) {
          const savedLists = getSavedLists();
          delete savedLists[name];
          saveLists(savedLists);
          renderSavedLists();
        }
      }

      function renameList(oldName) {
        const newName = prompt("Enter new name:", oldName);
        if (newName && newName.trim() && newName !== oldName) {
          const savedLists = getSavedLists();
          if (savedLists[newName]) {
            alert("A list with that name already exists");
            return;
          }

          savedLists[newName] = savedLists[oldName];
          delete savedLists[oldName];
          saveLists(savedLists);
          renderSavedLists();
        }
      }

      function renderSavedLists() {
        const container = document.getElementById("savedLists");
        const savedLists = getSavedLists();
        const listNames = Object.keys(savedLists).sort();

        if (listNames.length === 0) {
          container.innerHTML = '<div style="color: var(--muted); font-size: 0.9rem; text-align: center; padding: 20px;">No saved plans yet</div>';
          return;
        }

        container.innerHTML = listNames
          .map((name) => {
            const list = savedLists[name];
            const date = new Date(list.timestamp).toLocaleDateString();
            return `
            <div class="saved-item">
              <div class="saved-item-info">
                <div class="saved-item-name">${name}</div>
                <div class="saved-item-details">
                  ${list.targets ? list.targets.join(", ") : list.target} ‚Ä¢ ${list.combinedPrereqs ? list.combinedPrereqs.length : list.prerequisites.length} prerequisites ‚Ä¢ ${date}
                </div>
              </div>
              <div class="saved-item-actions">
                <button class="btn-small" onclick="loadList('${name}')">Load</button>
                <button class="btn-small" onclick="renameList('${name}')">Rename</button>
                <button class="btn-small danger" onclick="deleteList('${name}')">Delete</button>
              </div>
            </div>
          `;
          })
          .join("");
      }

      // Add enter key support for save input
      document.addEventListener("DOMContentLoaded", function () {
        const saveNameTopInput = document.getElementById("saveNameInput");

        saveNameTopInput.addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            saveCurrentListFromTop();
          }
        });
      });

      // Drag and drop functionality using SortableJS
      let sortableInstance = null;

      function initializeSortable() {
        const chainEl = document.getElementById("chain");
        const ol = chainEl.querySelector("ol");

        if (sortableInstance) {
          sortableInstance.destroy();
        }

        // Only initialize if there's an ordered list
        if (ol) {
          sortableInstance = new Sortable(ol, {
            animation: 150,
            ghostClass: "sortable-ghost",
            chosenClass: "sortable-chosen",
            dragClass: "sortable-drag",
            filter: ".no-drag", // Prevent dragging the target tech arrow
            onEnd: function (evt) {
              // Auto-reorder dependent technologies after moving a prerequisite
              autoReorderDependents(evt);
            },
          });
        }
      }

      function autoReorderDependents(evt) {
        if (!evt || !evt.item) return;

        const movedItem = evt.item.dataset.techName;
        if (!movedItem) return;

        const currentOrder = getCurrentOrder();
        if (currentOrder.length === 0) return;

        // Find the old and new positions of the moved item
        const oldIndex = parseInt(evt.oldIndex);
        const newIndex = parseInt(evt.newIndex);

        console.log(`Item ${movedItem} moved from position ${oldIndex} to position ${newIndex}`);

        let newOrder;
        if (newIndex > oldIndex) {
          // Moved further back - bring dependents behind it
          console.log("Moving item further back - bringing dependents behind it");
          newOrder = moveDependentsBehind(currentOrder, movedItem, newIndex);
        } else {
          // Moved earlier - bring dependencies before it
          console.log("Moving item earlier - bringing dependencies before it");
          newOrder = moveDependenciesBefore(currentOrder, movedItem, newIndex);
        }

        if (JSON.stringify(newOrder) !== JSON.stringify(currentOrder)) {
          console.log("Auto-reordering to fix dependency violations:", {
            movedItem,
            oldIndex,
            newIndex,
            oldOrder: currentOrder,
            newOrder,
          });
          renderCustomOrder(newOrder, true); // Animate the reordering
          // Update validation status after reordering animation completes
          setTimeout(() => {
            updateValidationStatus();
          }, 300); // Wait for animation to complete
        } else {
          console.log("No dependency violations found, order is valid");
          // Update validation status immediately if no reordering was needed
          updateValidationStatus();
        }
      }

      function moveDependentsBehind(order, movedItem, newIndex) {
        // Find all technologies that depend on the moved item (directly or indirectly)
        const dependents = new Set();

        function findDependents(prereq) {
          for (let i = 0; i < order.length; i++) {
            const tech = order[i];
            const prereqs = advances[tech]?.prereqs || [];

            if (prereqs.includes(prereq)) {
              dependents.add(tech);
              findDependents(tech); // Recursively find dependents of dependents
            }
          }
        }

        findDependents(movedItem);

        if (dependents.size === 0) {
          console.log(`${movedItem} has no dependents, no reordering needed`);
          return order;
        }

        console.log(`Found dependents of ${movedItem}:`, Array.from(dependents));

        // Create new order with dependents moved after the moved item
        const newOrder = [];
        const dependentsArray = Array.from(dependents);

        // Add items before the moved item
        for (let i = 0; i < newIndex; i++) {
          if (!dependents.has(order[i])) {
            newOrder.push(order[i]);
          }
        }

        // Add the moved item
        newOrder.push(movedItem);

        // Add all dependents in dependency order
        const orderedDependents = orderDependentsByDependency(dependentsArray);
        for (const dependent of orderedDependents) {
          newOrder.push(dependent);
        }

        // Add remaining items (excluding the moved item and its dependents)
        for (let i = newIndex + 1; i < order.length; i++) {
          if (!dependents.has(order[i])) {
            newOrder.push(order[i]);
          }
        }

        // Ensure all targets are included at the end if they're not already in the order
        selectedTargets.forEach((target) => {
          if (!newOrder.includes(target)) {
            newOrder.push(target);
          }
        });

        return newOrder;
      }

      function moveDependenciesBefore(order, movedItem, newIndex) {
        // Find all dependencies of the moved item that come after it
        const dependenciesAfter = [];
        const movedItemPrereqs = advances[movedItem]?.prereqs || [];

        for (const prereq of movedItemPrereqs) {
          const prereqIndex = order.indexOf(prereq);
          if (prereqIndex > newIndex) {
            dependenciesAfter.push(prereq);
          }
        }

        if (dependenciesAfter.length === 0) {
          console.log(`${movedItem} has no dependencies after its new position, no reordering needed`);
          return order;
        }

        console.log(`Found dependencies of ${movedItem} that need to be moved:`, dependenciesAfter);

        // Recursively find all dependencies that need to be moved
        const allDependenciesToMove = new Set();

        function addDependencyAndItsDependencies(tech) {
          allDependenciesToMove.add(tech);
          const techPrereqs = advances[tech]?.prereqs || [];

          for (const prereq of techPrereqs) {
            const prereqIndex = order.indexOf(prereq);
            if (prereqIndex > newIndex) {
              addDependencyAndItsDependencies(prereq);
            }
          }
        }

        for (const dependency of dependenciesAfter) {
          addDependencyAndItsDependencies(dependency);
        }

        // Create new order with dependencies moved before the moved item
        const newOrder = [];
        const dependenciesArray = Array.from(allDependenciesToMove);

        // Add items before the new position that aren't being moved
        for (let i = 0; i < newIndex; i++) {
          if (!allDependenciesToMove.has(order[i])) {
            newOrder.push(order[i]);
          }
        }

        // Add all dependencies in dependency order
        const orderedDependencies = orderDependentsByDependency(dependenciesArray);
        for (const dependency of orderedDependencies) {
          newOrder.push(dependency);
        }

        // Add the moved item
        newOrder.push(movedItem);

        // Add remaining items (excluding the moved item and its dependencies)
        for (let i = newIndex + 1; i < order.length; i++) {
          if (!allDependenciesToMove.has(order[i])) {
            newOrder.push(order[i]);
          }
        }

        // Ensure all targets are included at the end if they're not already in the order
        selectedTargets.forEach((target) => {
          if (!newOrder.includes(target)) {
            newOrder.push(target);
          }
        });

        return newOrder;
      }

      function orderDependentsByDependency(dependents) {
        // Sort dependents so that prerequisites come before their dependents
        const sorted = [];
        const added = new Set();

        function addWithPrereqs(tech) {
          if (added.has(tech)) return;

          const prereqs = advances[tech]?.prereqs || [];
          for (const prereq of prereqs) {
            if (dependents.includes(prereq)) {
              addWithPrereqs(prereq);
            }
          }

          sorted.push(tech);
          added.add(tech);
        }

        for (const tech of dependents) {
          addWithPrereqs(tech);
        }

        return sorted;
      }

      function updateValidationStatus() {
        if (selectedTargets.size === 0) {
          notesEl.style.display = "none";
          return;
        }

        const currentOrder = getCurrentOrder();

        // Get combined prerequisites for all targets
        const combinedPrereqs = getCombinedPrerequisites();
        const missingPrereqs = combinedPrereqs.filter((prereq) => !currentOrder.includes(prereq));

        // Check for prerequisite ordering issues
        const orderingIssues = [];
        for (let i = 0; i < currentOrder.length; i++) {
          const tech = currentOrder[i];
          const prereqs = advances[tech]?.prereqs || [];

          for (const prereq of prereqs) {
            const prereqIndex = currentOrder.indexOf(prereq);
            if (prereqIndex > i) {
              // Prerequisite comes after the technology that needs it
              orderingIssues.push(`${tech} requires ${prereq} to come first`);
            }
          }
        }

        console.log("Validation debug:", {
          currentOrder,
          combinedPrereqs,
          missingPrereqs,
          orderingIssues,
          selectedTargets: Array.from(selectedTargets),
        });

        // Debug: Show exactly what the ordering issues are
        if (orderingIssues.length > 0) {
          console.log("Ordering issues details:", orderingIssues);
        }

        if (missingPrereqs.length > 0) {
          notesEl.innerHTML = `‚ö†Ô∏è Warning: Missing prerequisites: ${missingPrereqs.join(", ")}. Drag them back into the list or use Reset Order.`;
          notesEl.className = "validation-status warning";
          notesEl.style.display = "block";
        } else if (orderingIssues.length > 0) {
          notesEl.innerHTML = `‚ö†Ô∏è Warning: Prerequisite order issues: ${orderingIssues.join(", ")}. Reorder technologies or use Reset Order.`;
          notesEl.className = "validation-status warning";
          notesEl.style.display = "block";
        } else {
          notesEl.innerHTML = `‚úÖ Valid research path`;
          notesEl.className = "validation-status valid";
          notesEl.style.display = "block";
        }
      }

      function getCurrentOrder() {
        const chainEl = document.getElementById("chain");
        const ol = chainEl.querySelector("ol");

        if (!ol) {
          return [];
        }

        const listItems = ol.children;

        console.log("getCurrentOrder debug:", {
          totalItems: listItems.length,
          items: Array.from(listItems).map((item, index) => ({
            index,
            text: item.textContent,
            dataset: item.dataset.techName,
            isTarget: item.dataset.isTarget,
            html: item.outerHTML,
            className: item.className,
            style: item.style.cssText,
          })),
        });

        const result = Array.from(listItems)
          .filter((item) => !item.classList.contains("no-drag"))
          .map((item, index) => {
            // Try to get from dataset first, fall back to tech-name div extraction
            if (item.dataset.techName) {
              console.log(`Item ${index}: Using dataset.techName = "${item.dataset.techName}"`);
              return item.dataset.techName;
            }
            // Extract from tech-name div (new structure)
            const techNameElement = item.querySelector(".tech-name");
            if (techNameElement) {
              const extracted = techNameElement.textContent.trim().replace(/^‚Üí\s*/, "");
              console.log(`Item ${index}: Extracted from tech-name div = "${extracted}"`);
              return extracted;
            }
            console.log(`Item ${index}: No tech name found`);
            return null;
          })
          .filter((name) => name && advances[name]); // Only include valid technology names

        console.log("Final getCurrentOrder result:", result);
        return result;
      }

      function ensurePrerequisiteIntegrity(order) {
        const currentTech = techSelect.value;
        if (!currentTech) return order;

        // Get all prerequisites needed for the target technology
        const targetPrereqs = prerequisiteChain(currentTech);
        const targetPrereqsSet = new Set(targetPrereqs);

        const validatedOrder = [];
        const added = new Set();

        // First, ensure all target prerequisites are included
        for (const prereq of targetPrereqs) {
          if (!added.has(prereq)) {
            validatedOrder.push(prereq);
            added.add(prereq);
          }
        }

        // Then add any additional technologies from the custom order
        for (const tech of order) {
          if (!added.has(tech)) {
            validatedOrder.push(tech);
            added.add(tech);
          }
        }

        return validatedOrder;
      }

      function renderCustomOrder(order, animate = false) {
        const chainEl = document.getElementById("chain");

        if (!animate) {
          // Direct render without animation
          chainEl.innerHTML = "";

          const ol = document.createElement("ol");
          order.forEach((tech, index) => {
            const li = document.createElement("li");
            li.dataset.techName = tech;

            // Check if this is a target technology
            const isTarget = selectedTargets.has(tech);
            if (isTarget) {
              li.classList.add("target");
            }

            // Add allows information with color coding
            const techAllows = getTechnologyAllows(tech);
            let allowsHtml = "";
            let allowsChips = [];

            Object.entries(techAllows).forEach(([category, items]) => {
              if (items.length > 0) {
                items.forEach((item) => {
                  const cssClass = category === "units" ? "unit" : category === "buildings" ? "building" : category === "wonders" ? "wonder" : "other";
                  allowsChips.push(`<span class="allows-chip allows-${cssClass}">${item}</span>`);
                });
              }
            });

            if (allowsChips.length > 0) {
              allowsHtml = `<div class="tech-allows">${allowsChips.join("")}</div>`;
            }

            const displayName = isTarget ? `‚Üí ${tech}` : tech;
            const className = isTarget ? "target" : "";

            li.innerHTML = `
              <div class="tech-name ${className}">${displayName}</div>
              ${allowsHtml}
            `;

            // Set target attributes if this is a target
            if (isTarget) {
              li.dataset.isTarget = "true";
            }

            ol.appendChild(li);
          });
          chainEl.appendChild(ol);

          // Add target techs at the end (only if they're not already in the order)
          selectedTargets.forEach((target) => {
            if (!order.includes(target)) {
              const final = document.createElement("li");
              final.innerHTML = `<strong class="accent">‚Üí ${target}</strong>`;
              final.style.cursor = "grab";
              final.dataset.techName = target;
              final.dataset.isTarget = "true";
              chainEl.appendChild(final);
            }
          });

          // Re-initialize SortableJS
          initializeSortable();
          // Update validation status after rendering
          updateValidationStatus();
          return;
        }

        // Animate existing elements moving to new positions
        const ol = chainEl.querySelector("ol");
        if (!ol) return;

        const currentItems = Array.from(ol.querySelectorAll("li:not(.no-drag)"));
        const currentOrder = currentItems.map((item) => item.dataset.techName);

        // If orders are the same, no animation needed
        if (JSON.stringify(currentOrder) === JSON.stringify(order)) {
          return;
        }

        // Create a map of current positions
        const currentPositions = {};
        currentItems.forEach((item, index) => {
          currentPositions[item.dataset.techName] = index;
        });

        // Create a map of new positions
        const newPositions = {};
        order.forEach((tech, index) => {
          newPositions[tech] = index;
        });

        // Update styling for existing items that are targets
        currentItems.forEach((item) => {
          const techName = item.dataset.techName;
          if (selectedTargets.has(techName)) {
            // Update the display to show it's a target
            const strongElement = item.querySelector("strong");
            if (strongElement) {
              strongElement.textContent = `‚Üí ${techName}`;
              strongElement.className = "accent";
            }
            item.dataset.isTarget = "true";
          }
        });

        // Add target techs at the end (only if they're not already in the order)
        selectedTargets.forEach((target) => {
          if (!order.includes(target)) {
            const final = document.createElement("li");
            final.classList.add("target");
            final.innerHTML = `
              <div class="tech-name target">‚Üí ${target}</div>
            `;
            final.dataset.techName = target;
            final.dataset.isTarget = "true";
            ol.appendChild(final);
          }
        });

        // Enable animations on all items
        currentItems.forEach((item) => {
          item.style.transition = "transform 0.5s ease";
        });

        // Animate each item to its new position
        currentItems.forEach((item, index) => {
          const techName = item.dataset.techName;
          const oldPosition = currentPositions[techName];
          const newPosition = newPositions[techName];

          if (oldPosition !== newPosition) {
            console.log(`${techName} moving from position ${oldPosition} to position ${newPosition}`);

            // Calculate the transform needed
            const itemHeight = item.offsetHeight + 8; // Include margin
            const deltaY = (newPosition - oldPosition) * itemHeight;

            // Apply the transform
            item.style.transform = `translateY(${deltaY}px)`;

            // After animation completes, update the DOM order
            setTimeout(() => {
              item.style.transition = "none";
              item.style.transform = "";

              // Move the item to its correct position in the DOM
              const targetIndex = newPosition;
              if (targetIndex < ol.children.length) {
                ol.insertBefore(item, ol.children[targetIndex]);
              } else {
                ol.appendChild(item);
              }
            }, 500);
          }
        });

        // Re-initialize SortableJS after all animations complete
        setTimeout(() => {
          initializeSortable();
          // Update validation status after reordering is complete
          updateValidationStatus();
        }, 600);
      }

      function clearAll() {
        // Clear all selected targets
        selectedTargets.clear();

        // Update the UI
        updateMultiTargetUI();
        renderMultiTargetChain();
      }

      // Update the save function to include custom order
      function scrollToSaveAndFocus() {
        const saveSection = document.querySelector(".saved-plans");
        const nameInput = document.getElementById("saveNameInput");

        // Smooth scroll to the save section
        saveSection.scrollIntoView({
          behavior: "smooth",
          block: "start",
        });

        // Focus the input after a short delay to ensure scroll completes
        setTimeout(() => {
          nameInput.focus();
        }, 300);
      }

      function saveCurrentList() {
        const nameInput = document.getElementById("saveNameInput");
        const name = nameInput.value.trim();

        if (!name) {
          alert("Please enter a name for your list");
          return;
        }

        if (selectedTargets.size === 0) {
          alert("Please add at least one target technology first");
          return;
        }

        const targets = Array.from(selectedTargets);
        const combinedPrereqs = getCombinedPrerequisites();
        const customOrder = getCurrentOrder();

        // Validate the custom order and show warning if invalid
        const missingPrereqs = combinedPrereqs.filter((prereq) => !customOrder.includes(prereq));

        if (missingPrereqs.length > 0) {
          const warning = `Warning: Your custom order is missing some prerequisites: ${missingPrereqs.join(", ")}. These will be automatically added when you research this path.`;
          if (!confirm(warning + "\n\nDo you want to save anyway?")) {
            return;
          }
        }

        const savedLists = getSavedLists();

        savedLists[name] = {
          targets: targets,
          combinedPrereqs: combinedPrereqs,
          customOrder: customOrder.length > 0 ? customOrder : null,
          timestamp: Date.now(),
        };

        saveLists(savedLists);
        nameInput.value = "";
        renderSavedLists();

        // Show success message
        const saveBtn = document.querySelector(".btn.primary");
        const originalText = saveBtn.textContent;
        saveBtn.textContent = "Saved!";
        saveBtn.style.background = "#34d399";
        setTimeout(() => {
          saveBtn.textContent = originalText;
          saveBtn.style.background = "var(--accent)";
        }, 1500);
      }

      // Update the load function to restore custom order
      function loadList(name) {
        const savedLists = getSavedLists();
        const list = savedLists[name];

        if (list && (list.target || list.targets)) {
          // Handle both old single-target and new multi-target formats
          if (list.targets) {
            // Multi-target format
            selectedTargets = new Set(list.targets);
            updateMultiTargetUI();
            renderMultiTargetChain();
          } else {
            // Single-target format (backward compatibility)
            selectedTargets = new Set([list.target]);
            updateMultiTargetUI();
            renderMultiTargetChain();
          }

          // Restore custom order if it exists
          if (list.customOrder && list.customOrder.length > 0) {
            setTimeout(() => {
              renderCustomOrder(list.customOrder);
            }, 100);
          }

          // Show a brief success message
          const loadBtn = event.target;
          const originalText = loadBtn.textContent;
          loadBtn.textContent = "Loaded!";
          loadBtn.style.background = "var(--accent)";
          loadBtn.style.color = "#000";
          setTimeout(() => {
            loadBtn.textContent = originalText;
            loadBtn.style.background = "transparent";
            loadBtn.style.color = "var(--accent)";
          }, 1000);
        }
      }

      // Initialise
      render();
      renderSavedLists();
    </script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WFXE64P7XQ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-WFXE64P7XQ");
    </script>
  </body>
</html>
