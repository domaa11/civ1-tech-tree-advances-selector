<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Civilization I - Multi-Target Tech Planner</title>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
      :root {
        --bg: #0f172a;
        --panel: #111827;
        --muted: #94a3b8;
        --text: #e5e7eb;
        --accent: #38bdf8;
        --unit-color: #fbbf24;
        --building-color: #34d399;
        --wonder-color: #a78bfa;
        --other-color: #f87171;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, Helvetica, sans-serif;
        background: var(--bg);
        color: var(--text);
      }
      .wrap {
        max-width: 900px;
        margin: 40px auto;
        padding: 24px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      }
      h1 {
        margin: 0 0 12px;
        font-size: 24px;
        letter-spacing: 0.3px;
      }
      p {
        margin: 0 0 16px;
        color: var(--muted);
      }
      select,
      input[type="text"] {
        width: 100%;
        padding: 12px 14px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: #0b1220;
        color: var(--text);
      }
      .row {
        display: grid;
        gap: 14px;
        grid-template-columns: 1fr;
      }
      @media (min-width: 720px) {
        .row {
          grid-template-columns: 1fr 1fr;
        }
      }
      .panel {
        padding: 16px;
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
      }
      .muted {
        color: var(--muted);
      }
      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .chip {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: #0f172a;
        font-size: 13px;
      }
      .list {
        margin-top: 10px;
      }
      .list li {
        margin: 6px 0;
        padding: 8px 10px;
        border-radius: 8px;
        background: #0f172a;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      .small {
        font-size: 12px;
      }
      .accent {
        color: var(--accent);
      }
      .allows-chip {
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 4px;
        margin-left: 8px;
        font-weight: 500;
      }
      .allows-unit {
        background: #fbbf24;
        color: #000;
      }
      .allows-building {
        background: #34d399;
        color: #000;
      }
      .allows-wonder {
        background: #a78bfa;
        color: #000;
      }
      .allows-other {
        background: #f87171;
        color: #000;
      }
      .allows-list {
        margin-top: 4px;
        font-size: 11px;
        color: var(--muted);
      }
      .footer {
        margin-top: 20px;
        font-size: 12px;
        color: var(--muted);
      }
      .inline-code {
        padding: 0.1em 0.4em;
        border-radius: 6px;
        background: #0b1220;
        border: 1px solid rgba(255, 255, 255, 0.08);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }

      /* SortableJS visual feedback */
      .sortable-ghost {
        opacity: 0.4;
        background: rgba(56, 189, 248, 0.1) !important;
      }

      .sortable-chosen {
        background: rgba(56, 189, 248, 0.2) !important;
      }

      .sortable-drag {
        opacity: 0.8;
        transform: rotate(5deg);
      }

      .no-drag {
        cursor: default !important;
      }

      /* Ensure inputs stay within their containers */
      input,
      select {
        width: 100%;
        box-sizing: border-box;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Sid Meier’s Civilization I – Tech Prerequisite Explorer</h1>
      <p>Plan your technology path by selecting multiple target technologies. The app will show you all prerequisites needed and let you reorder them to optimize your research strategy.</p>

      <div class="row">
        <div class="panel">
          <h3 style="margin-top: 0; margin-bottom: 16px; color: var(--accent)">How to Use</h3>
          <div style="margin-bottom: 16px; padding: 12px; background: rgba(56, 189, 248, 0.05); border-radius: 8px; font-size: 13px; line-height: 1.5">
            <p style="margin: 0 0 8px 0"><strong>1. Add Target Technologies</strong></p>
            <p style="margin: 0 0 8px 0">Click "+ Add Target" on the right to select technologies you want to research.</p>
            <p style="margin: 0 0 8px 0"><strong>2. Reorder Research</strong></p>
            <p style="margin: 0 0 8px 0">Drag technologies to optimize your research order.</p>
            <p style="margin: 0 0 8px 0"><strong>3. Save Your Plan</strong></p>
            <p style="margin: 0">Save your optimized research path for later reference.</p>
          </div>

          <!-- Saved Lists Section -->
          <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.08)">
            <h4 style="margin: 0 0 12px 0; color: var(--text)">Saved Plans</h4>
            <div id="savedLists" style="margin-top: 12px">
              <!-- Saved lists will appear here -->
            </div>
          </div>
        </div>

        <div class="panel">
          <!-- Save Button at Top -->
          <div style="display: flex; gap: 8px; margin-bottom: 16px; padding: 12px; background: rgba(56, 189, 248, 0.1); border: 1px solid rgba(56, 189, 248, 0.2); border-radius: 8px">
            <input
              id="saveNameTop"
              type="text"
              placeholder="Save this list as..."
              style="flex: 1; padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.15); background: #0b1220; color: var(--text); font-size: 13px"
            />
            <button
              id="saveBtnTop"
              onclick="saveCurrentListFromTop()"
              style="padding: 8px 16px; border-radius: 6px; border: 1px solid var(--accent); background: var(--accent); color: #000; font-weight: 500; cursor: pointer; font-size: 13px"
            >
              Save List
            </button>
          </div>

          <!-- Multi-Target Section -->
          <div id="multiTargetSection" style="margin-bottom: 16px; padding: 12px; background: rgba(56, 189, 248, 0.05); border: 1px solid rgba(56, 189, 248, 0.1); border-radius: 8px">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px">
              <label class="muted small">Targets:</label>
              <button
                id="addTargetBtn"
                onclick="showAddTargetDropdown()"
                style="padding: 4px 8px; border-radius: 4px; border: 1px solid var(--accent); background: transparent; color: var(--accent); font-size: 11px; cursor: pointer"
              >
                + Add Target
              </button>
            </div>
            <div id="targetPills" style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px">
              <!-- Target pills will appear here -->
            </div>
            <div id="targetSummary" class="muted small">
              <!-- Combined prerequisite count will appear here -->
            </div>
          </div>

          <!-- Add Target Dropdown (hidden by default) -->
          <div
            id="addTargetDropdown"
            style="
              display: none;
              position: absolute;
              background: #0b1220;
              border: 1px solid rgba(255, 255, 255, 0.15);
              border-radius: 8px;
              padding: 8px;
              width: 250px;
              max-height: 300px;
              z-index: 1000;
              margin-top: 4px;
            "
          >
            <!-- Technology options will be populated here -->
          </div>

          <div class="chips" id="summary"></div>

          <!-- Reorderable List Section -->
          <div style="margin-top: 16px">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px">
              <label class="muted small">Research Order (drag to reorder)</label>
              <button
                id="resetOrderBtn"
                onclick="resetToOriginalOrder()"
                style="padding: 4px 8px; border-radius: 4px; border: 1px solid var(--muted); background: transparent; color: var(--muted); font-size: 11px; cursor: pointer"
              >
                Reset Order
              </button>
            </div>
            <ol class="list" id="chain" style="cursor: grab"></ol>
          </div>

          <div id="notes" class="footer"></div>
        </div>
      </div>
    </div>

    <script>
      // --- Global state for multiple targets ---
      let selectedTargets = new Set();

      // --- Unified data structure: tech -> { prereqs: [], allows: {} } ---
      // Source: Civilization Wiki - https://civilization.fandom.com/wiki/List_of_advances_in_Civ1
      const advances = {
        "Advanced Flight": {
          prereqs: ["Flight", "Electricity"],
          allows: { units: ["Bomber", "Carrier"] },
        },
        Alphabet: {
          prereqs: [],
          allows: {},
        },
        Astronomy: {
          prereqs: ["Mysticism", "Mathematics"],
          allows: { wonders: ["Copernicus' Observatory"] },
        },
        "Atomic Theory": {
          prereqs: ["Theory of Gravity", "Physics"],
          allows: {},
        },
        Automobile: {
          prereqs: ["Combustion", "Steel"],
          allows: { units: ["Armor"] },
        },
        Banking: {
          prereqs: ["Trade", "The Republic"],
          allows: { buildings: ["Bank"] },
        },
        "Bridge Building": {
          prereqs: ["Iron Working", "Alphabet"],
          allows: { other: ["Road on river squares"] },
        },
        "Bronze Working": {
          prereqs: [],
          allows: { units: ["Phalanx"], wonders: ["Colossus"] },
        },
        "Ceremonial Burial": {
          prereqs: [],
          allows: { buildings: ["Temple"] },
        },
        Chemistry: {
          prereqs: ["University", "Medicine"],
          allows: {},
        },
        Chivalry: {
          prereqs: ["Feudalism", "Horseback Riding"],
          allows: { units: ["Knights"] },
        },
        "Code of Laws": {
          prereqs: ["Alphabet"],
          allows: { buildings: ["Courthouse"] },
        },
        Combustion: {
          prereqs: ["Refining", "Explosives"],
          allows: { units: ["Cruiser"] },
        },
        Communism: {
          prereqs: ["Philosophy", "Industrialization"],
          allows: { other: ["Communism"], wonders: ["United Nations"] },
        },
        Computers: {
          prereqs: ["Mathematics", "Electronics"],
          allows: { wonders: ["SETI Program"] },
        },
        Conscription: {
          prereqs: ["The Republic", "Explosives"],
          allows: { units: ["Riflemen"] },
        },
        Construction: {
          prereqs: ["Masonry", "Currency"],
          allows: { other: ["Fortress"], buildings: ["Aqueduct", "Colosseum"] },
        },
        "The Corporation": {
          prereqs: ["Banking", "Industrialization"],
          allows: {},
        },
        Currency: {
          prereqs: ["Bronze Working"],
          allows: { buildings: ["Marketplace"] },
        },
        Democracy: {
          prereqs: ["Philosophy", "Literacy"],
          allows: { other: ["Democracy"] },
        },
        Electricity: {
          prereqs: ["Magnetism", "Metallurgy"],
          allows: {},
        },
        Electronics: {
          prereqs: ["Electricity", "Engineering"],
          allows: { buildings: ["Hydro Plant"], wonders: ["Hoover Dam"] },
        },
        Engineering: {
          prereqs: ["The Wheel", "Construction"],
          allows: {},
        },
        Explosives: {
          prereqs: ["Gunpowder", "Chemistry"],
          allows: {},
        },
        Feudalism: {
          prereqs: ["Masonry", "Monarchy"],
          allows: {},
        },
        Flight: {
          prereqs: ["Combustion", "Physics"],
          allows: { units: ["Fighter"] },
        },
        "Fusion Power": {
          prereqs: ["Nuclear Power", "Superconductor"],
          allows: {},
        },
        "Future Tech": {
          prereqs: ["Fusion Power"],
          allows: {},
        },
        "Genetic Engineering": {
          prereqs: ["Medicine", "The Corporation"],
          allows: { wonders: ["Cure for Cancer"] },
        },
        Gunpowder: {
          prereqs: ["Invention", "Iron Working"],
          allows: { units: ["Musketeers"] },
        },
        "Horseback Riding": {
          prereqs: [],
          allows: { units: ["Cavalry"] },
        },
        Industrialization: {
          prereqs: ["Railroad", "Banking"],
          allows: { units: ["Transport"], buildings: ["Factory"], wonders: ["Women's Suffrage"] },
        },
        Invention: {
          prereqs: ["Engineering", "Literacy"],
          allows: {},
        },
        "Iron Working": {
          prereqs: ["Bronze Working"],
          allows: { units: ["Legion"] },
        },
        "Labor Union": {
          prereqs: ["Mass Production", "Communism"],
          allows: { units: ["Mech. Inf."] },
        },
        Literacy: {
          prereqs: ["Writing", "Code of Laws"],
          allows: { wonders: ["Great Library"] },
        },
        Magnetism: {
          prereqs: ["Navigation", "Physics"],
          allows: { units: ["Frigate"] },
        },
        Mapmaking: {
          prereqs: ["Alphabet"],
          allows: { wonders: ["Lighthouse"], units: ["Trireme"] },
        },
        Masonry: {
          prereqs: [],
          allows: { buildings: ["City Walls", "Palace"], wonders: ["Pyramids", "Great Wall"] },
        },
        "Mass Production": {
          prereqs: ["Automobile", "The Corporation"],
          allows: { units: ["Submarine"], buildings: ["Mass Transit"] },
        },
        Mathematics: {
          prereqs: ["Alphabet", "Masonry"],
          allows: { units: ["Catapult"] },
        },
        Medicine: {
          prereqs: ["Philosophy", "Trade"],
          allows: { wonders: ["Shakespeare's Theatre"] },
        },
        Metallurgy: {
          prereqs: ["Gunpowder", "University"],
          allows: { units: ["Cannon"] },
        },
        Monarchy: {
          prereqs: ["Ceremonial Burial", "Code of Laws"],
          allows: { other: ["Monarchy"] },
        },
        Mysticism: {
          prereqs: ["Ceremonial Burial"],
          allows: { wonders: ["Oracle"] },
        },
        Navigation: {
          prereqs: ["Mapmaking", "Astronomy"],
          allows: { wonders: ["Magellan's Expedition"], units: ["Sail"] },
        },
        "Nuclear Fission": {
          prereqs: ["Mass Production", "Atomic Theory"],
          allows: { wonders: ["Manhattan Project"] },
        },
        "Nuclear Power": {
          prereqs: ["Nuclear Fission", "Electronics"],
          allows: { buildings: ["Nuclear Plant"] },
        },
        Philosophy: {
          prereqs: ["Mysticism", "Literacy"],
          allows: {},
        },
        Physics: {
          prereqs: ["Mathematics", "Navigation"],
          allows: {},
        },
        Plastics: {
          prereqs: ["Refining", "Space Flight"],
          allows: { wonders: ["SS Component"] },
        },
        Pottery: {
          prereqs: [],
          allows: { buildings: ["Granary"], wonders: ["Hanging Gardens"] },
        },
        Railroad: {
          prereqs: ["Steam Engine", "Bridge Building"],
          allows: { other: ["RailRoad on road squares"], wonders: ["Darwin's Voyage"] },
        },
        Recycling: {
          prereqs: ["Mass Production", "Democracy"],
          allows: { buildings: ["Recycling Center"] },
        },
        Refining: {
          prereqs: ["Chemistry", "The Corporation"],
          allows: { buildings: ["Power Plant"] },
        },
        Religion: {
          prereqs: ["Philosophy", "Writing"],
          allows: { wonders: ["Michelangelo's Chapel", "J.S. Bach's Cathedral"], buildings: ["Cathedral"] },
        },
        "The Republic": {
          prereqs: ["Code of Laws", "Literacy"],
          allows: { other: ["Republic"] },
        },
        Robotics: {
          prereqs: ["Plastics", "Computers"],
          allows: { units: ["Artillery"], buildings: ["Mfg. Plant"], wonders: ["SS Module"] },
        },
        Rocketry: {
          prereqs: ["Advanced Flight", "Electronics"],
          allows: { units: ["Nuclear unit (with Manhattan Project)"] },
        },
        "Space Flight": {
          prereqs: ["Computers", "Rocketry"],
          allows: { wonders: ["Apollo Program", "SS Structural"] },
        },
        "Steam Engine": {
          prereqs: ["Physics", "Invention"],
          allows: { units: ["Ironclad"] },
        },
        Steel: {
          prereqs: ["Metallurgy", "Industrialization"],
          allows: { units: ["Battleship"] },
        },
        Superconductor: {
          prereqs: ["Plastics", "Mass Production"],
          allows: { buildings: ["SDI Defense"] },
        },
        "Theory of Gravity": {
          prereqs: ["Astronomy", "University"],
          allows: { wonders: ["Isaac Newton's College"] },
        },
        Trade: {
          prereqs: ["Currency", "Code of Laws"],
          allows: { units: ["Caravan"] },
        },
        University: {
          prereqs: ["Mathematics", "Philosophy"],
          allows: { buildings: ["University"] },
        },
        "The Wheel": {
          prereqs: [],
          allows: { units: ["Chariot"] },
        },
        Writing: {
          prereqs: ["Alphabet"],
          allows: { buildings: ["Library"], units: ["Diplomat"] },
        },
      };

      // Build an alphabetised list of techs
      const allTechs = Object.keys(advances).sort((a, b) => a.localeCompare(b));

      const chainEl = document.getElementById("chain");
      const summaryEl = document.getElementById("summary");
      const notesEl = document.getElementById("notes");

      // Helper function to categorize an item
      function categorizeItem(item) {
        // Search through all advances to find which category this item belongs to
        for (const [techName, techData] of Object.entries(advances)) {
          const allows = techData.allows || {};
          for (const [category, items] of Object.entries(allows)) {
            if (Array.isArray(items) && items.includes(item)) {
              return category;
            }
          }
        }
        return "other";
      }

      // Helper function to get allows for a technology
      function getTechnologyAllows(tech) {
        const techAllows = advances[tech]?.allows || {};
        const categorized = { units: [], buildings: [], wonders: [], other: [] };

        // Process each category in the allows data
        Object.entries(techAllows).forEach(([category, items]) => {
          if (Array.isArray(items)) {
            items.forEach((item) => {
              const itemCategory = categorizeItem(item);
              if (!categorized[itemCategory].includes(item)) {
                categorized[itemCategory].push(item);
              }
            });
          }
        });

        return categorized;
      }

      // Depth-first search to gather prerequisites; returns in dependency order (prereqs first)
      function prerequisiteChain(target) {
        const seen = new Set();
        const order = [];
        function dfs(tech) {
          if (seen.has(tech)) return; // prevent cycles
          seen.add(tech);
          const reqs = advances[tech]?.prereqs || [];
          reqs.forEach(dfs); // ensure requirements come first
          order.push(tech);
        }
        // Build graph back from target; we don't include the target when reporting "needed" list
        const reqs = advances[target]?.prereqs || [];
        reqs.forEach(dfs);
        return order; // this contains only prerequisites, correctly ordered, no duplicates
      }

      function render() {
        // This function is no longer needed since we only use the multi-target system
        // The renderMultiTargetChain function handles all rendering now
      }

      function renderMultiTargetChain() {
        if (selectedTargets.size === 0) {
          summaryEl.innerHTML = "";
          chainEl.innerHTML = "";
          notesEl.innerHTML = "";
          return;
        }

        // Check if there's a custom order to preserve
        // Don't use getCurrentOrder() here as it can create circular dependency
        const chainEl = document.getElementById("chain");
        const existingItems = chainEl.querySelectorAll("li:not(.no-drag)");
        const hasCustomOrder = existingItems.length > 0;

        let currentOrder = [];
        if (hasCustomOrder) {
          // Read the order directly from the DOM elements in their visual order
          currentOrder = Array.from(existingItems)
            .map((item) => item.dataset.techName)
            .filter((name) => name && advances[name]);

          console.log("Reading custom order from DOM:", currentOrder);
        }

        // Get combined prerequisites for all targets
        const combinedPrereqs = getCombinedPrerequisites();

        console.log("renderMultiTargetChain debug:", {
          selectedTargets: Array.from(selectedTargets),
          currentOrder,
          hasCustomOrder,
          combinedPrereqs,
          combinedPrereqsLength: combinedPrereqs.length,
        });

        // Summary chips
        summaryEl.innerHTML = "";
        const chip1 = document.createElement("div");
        chip1.className = "chip";
        chip1.textContent = `Targets: ${Array.from(selectedTargets).join(", ")}`;
        summaryEl.appendChild(chip1);
        const chip2 = document.createElement("div");
        chip2.className = "chip";
        chip2.textContent = `Prerequisites: ${combinedPrereqs.length}`;
        summaryEl.appendChild(chip2);

        // Add color legend
        const legend = document.createElement("div");
        legend.style.marginTop = "12px";
        legend.style.fontSize = "11px";
        legend.style.color = "var(--muted)";
        legend.innerHTML = `
          <div style="margin-bottom: 4px;"><strong>Allows:</strong></div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <span class="allows-chip allows-unit">Units</span>
            <span class="allows-chip allows-building">Buildings</span>
            <span class="allows-chip allows-wonder">Wonders</span>
            <span class="allows-chip allows-other">Other</span>
          </div>
        `;
        summaryEl.appendChild(legend);

        // Render the ordered list
        chainEl.innerHTML = "";
        if (!combinedPrereqs.length) {
          const li = document.createElement("li");
          li.innerHTML = `<strong>${Array.from(selectedTargets).join(", ")}</strong> have no prerequisites.`;
          chainEl.appendChild(li);
        } else if (hasCustomOrder) {
          // Use the existing custom order, but ensure all targets are included
          const allTechsInOrder = [...currentOrder];

          // Add any missing targets to the end
          selectedTargets.forEach((target) => {
            if (!allTechsInOrder.includes(target)) {
              allTechsInOrder.push(target);
            }
          });

          allTechsInOrder.forEach((tech) => {
            const li = document.createElement("li");
            const deps = "";

            // Add allows information with color coding
            const techAllows = getTechnologyAllows(tech);
            let allowsHtml = "";
            let allowsChips = [];

            Object.entries(techAllows).forEach(([category, items]) => {
              if (items.length > 0) {
                // Create individual chips for each item
                items.forEach((item) => {
                  // Map category names to singular form for CSS classes
                  const cssClass = category === "units" ? "unit" : category === "buildings" ? "building" : category === "wonders" ? "wonder" : "other";
                  allowsChips.push(`<span class="allows-chip allows-${cssClass}">${item}</span>`);
                });
              }
            });

            if (allowsChips.length > 0) {
              allowsHtml = allowsChips.join("");
            }

            // Check if this is a target technology
            const isTarget = selectedTargets.has(tech);
            const displayName = isTarget ? `→ ${tech}` : tech;
            const className = isTarget ? "accent" : "";

            li.innerHTML = `<strong class="${className}">${displayName}</strong>${deps}${allowsHtml}`;
            li.style.cursor = "grab";
            li.dataset.techName = tech;
            if (isTarget) {
              li.dataset.isTarget = "true";
            }
            chainEl.appendChild(li);
          });
        } else {
          // Use default prerequisite order
          combinedPrereqs.forEach((t, idx) => {
            const li = document.createElement("li");
            const deps = "";

            // Add allows information with color coding
            const techAllows = getTechnologyAllows(t);
            let allowsHtml = "";
            let allowsChips = [];

            Object.entries(techAllows).forEach(([category, items]) => {
              if (items.length > 0) {
                // Create individual chips for each item
                items.forEach((item) => {
                  // Map category names to singular form for CSS classes
                  const cssClass = category === "units" ? "unit" : category === "buildings" ? "building" : category === "wonders" ? "wonder" : "other";
                  allowsChips.push(`<span class="allows-chip allows-${cssClass}">${item}</span>`);
                });
              }
            });

            if (allowsChips.length > 0) {
              allowsHtml = allowsChips.join("");
            }

            li.innerHTML = `<strong>${t}</strong>${deps}${allowsHtml}`;
            li.style.cursor = "grab";
            li.dataset.techName = t;
            chainEl.appendChild(li);
          });

          // Add target techs at the end
          selectedTargets.forEach((target) => {
            const final = document.createElement("li");
            final.innerHTML = `<strong class="accent">→ ${target}</strong>`;
            final.style.cursor = "grab";
            final.dataset.techName = target;
            final.dataset.isTarget = "true";
            chainEl.appendChild(final);
          });
        }

        // Initialize SortableJS after rendering
        initializeSortable();

        // Set initial validation status
        updateValidationStatus();
      }

      function getCombinedPrerequisites() {
        const allPrereqs = new Set();

        selectedTargets.forEach((target) => {
          const prereqs = prerequisiteChain(target);
          console.log(`Prerequisites for ${target}:`, prereqs);
          prereqs.forEach((prereq) => allPrereqs.add(prereq));
        });

        const result = Array.from(allPrereqs);
        console.log("Combined prerequisites:", result);
        return result;
      }

      function updateMultiTargetUI() {
        const pillsContainer = document.getElementById("targetPills");
        pillsContainer.innerHTML = "";

        selectedTargets.forEach((target) => {
          const pill = document.createElement("span");
          pill.style.cssText = `
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: rgba(56, 189, 248, 0.1);
            border: 1px solid rgba(56, 189, 248, 0.2);
            border-radius: 12px;
            font-size: 12px;
            color: var(--accent);
          `;

          pill.innerHTML = `
            ${target}
            <button onclick="removeTarget('${target}')" style="
              background: none;
              border: none;
              color: var(--accent);
              cursor: pointer;
              font-size: 14px;
              padding: 0;
              margin: 0;
              line-height: 1;
            ">×</button>
          `;

          pillsContainer.appendChild(pill);
        });

        updateMultiTargetSummary();

        // Update validation status after UI changes
        setTimeout(() => {
          updateValidationStatus();
        }, 0);
      }

      function updateMultiTargetSummary() {
        const summaryEl = document.getElementById("targetSummary");
        const prereqCount = getCombinedPrerequisites().length;

        if (selectedTargets.size === 1) {
          const target = Array.from(selectedTargets)[0];
          summaryEl.textContent = `Prerequisites: ${prereqCount}`;
        } else {
          summaryEl.textContent = `Combined prerequisites: ${prereqCount} (from ${selectedTargets.size} targets)`;
        }
      }

      function showAddTargetDropdown() {
        const dropdown = document.getElementById("addTargetDropdown");
        const addBtn = document.getElementById("addTargetBtn");

        if (dropdown.style.display === "block") {
          dropdown.style.display = "none";
          return;
        }

        // Position the dropdown near the add button
        const btnRect = addBtn.getBoundingClientRect();
        dropdown.style.left = `${btnRect.left}px`;
        dropdown.style.top = `${btnRect.bottom + 4}px`;

        // Create dropdown content with search
        dropdown.innerHTML = `
          <div style="margin-bottom: 8px;">
            <input 
              id="targetSearchInput" 
              type="text" 
              placeholder="Search technologies..." 
              style="
                width: 100%;
                padding: 6px 8px;
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 4px;
                background: #0b1220;
                color: var(--text);
                font-size: 13px;
                box-sizing: border-box;
              "
            />
          </div>
          <div id="targetOptions" style="max-height: 150px; overflow-y: auto;">
            <!-- Technology options will be populated here -->
          </div>
        `;

        // Get the options container
        const optionsContainer = dropdown.querySelector("#targetOptions");
        const searchInput = dropdown.querySelector("#targetSearchInput");

        // Function to populate options based on search
        function populateTargetOptions(searchTerm = "") {
          optionsContainer.innerHTML = "";
          const filteredTechs = Object.keys(advances).filter((tech) => {
            if (selectedTargets.has(tech)) return false;
            if (!searchTerm) return true;
            return tech.toLowerCase().includes(searchTerm.toLowerCase());
          });

          filteredTechs.forEach((tech) => {
            const option = document.createElement("div");
            option.style.cssText = `
              padding: 6px 8px;
              cursor: pointer;
              border-radius: 4px;
              font-size: 13px;
            `;
            option.textContent = tech;
            option.onmouseenter = () => (option.style.background = "rgba(255, 255, 255, 0.1)");
            option.onmouseleave = () => (option.style.background = "transparent");
            option.onclick = () => {
              selectedTargets.add(tech);
              updateMultiTargetUI();
              renderMultiTargetChain();
              dropdown.style.display = "none";
            };
            optionsContainer.appendChild(option);
          });
        }

        // Initial population
        populateTargetOptions();

        // Add search functionality
        searchInput.addEventListener("input", (e) => {
          populateTargetOptions(e.target.value);
        });

        // Focus the search input
        setTimeout(() => {
          searchInput.focus();
        }, 0);

        dropdown.style.display = "block";

        // Close dropdown when clicking outside
        setTimeout(() => {
          document.addEventListener("click", function closeDropdown(e) {
            if (!dropdown.contains(e.target) && !addBtn.contains(e.target)) {
              dropdown.style.display = "none";
              document.removeEventListener("click", closeDropdown);
            }
          });
        }, 0);
      }

      function removeTarget(target) {
        selectedTargets.delete(target);
        updateMultiTargetUI();
        renderMultiTargetChain();
      }

      // Save/Load functionality
      const STORAGE_KEY = "civ1_tech_lists";

      function getSavedLists() {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          return saved ? JSON.parse(saved) : {};
        } catch (e) {
          console.error("Error loading saved lists:", e);
          return {};
        }
      }

      function saveLists(lists) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(lists));
        } catch (e) {
          console.error("Error saving lists:", e);
        }
      }

      function saveCurrentListFromTop() {
        const nameInput = document.getElementById("saveNameTop");
        const name = nameInput.value.trim();

        if (!name) {
          alert("Please enter a name for your list");
          return;
        }

        if (selectedTargets.size === 0) {
          alert("Please select at least one technology first");
          return;
        }

        const combinedPrereqs = getCombinedPrerequisites();
        const customOrder = getCurrentOrder();
        const savedLists = getSavedLists();

        savedLists[name] = {
          targets: Array.from(selectedTargets),
          prerequisites: combinedPrereqs,
          customOrder: customOrder.length > 0 ? customOrder : null,
          timestamp: Date.now(),
        };

        saveLists(savedLists);
        nameInput.value = "";
        renderSavedLists();

        // Show success message
        const saveBtn = document.getElementById("saveBtnTop");
        const originalText = saveBtn.textContent;
        saveBtn.textContent = "Saved!";
        saveBtn.style.background = "#34d399";
        setTimeout(() => {
          saveBtn.textContent = originalText;
          saveBtn.style.background = "var(--accent)";
        }, 1500);
      }

      function deleteList(name) {
        if (confirm(`Delete "${name}"?`)) {
          const savedLists = getSavedLists();
          delete savedLists[name];
          saveLists(savedLists);
          renderSavedLists();
        }
      }

      function renameList(oldName) {
        const newName = prompt("Enter new name:", oldName);
        if (newName && newName.trim() && newName !== oldName) {
          const savedLists = getSavedLists();
          if (savedLists[newName]) {
            alert("A list with that name already exists");
            return;
          }

          savedLists[newName] = savedLists[oldName];
          delete savedLists[oldName];
          saveLists(savedLists);
          renderSavedLists();
        }
      }

      function renderSavedLists() {
        const container = document.getElementById("savedLists");
        const savedLists = getSavedLists();
        const listNames = Object.keys(savedLists).sort();

        if (listNames.length === 0) {
          container.innerHTML = '<div style="color: var(--muted); font-size: 12px; text-align: center; padding: 12px;">No saved lists yet</div>';
          return;
        }

        container.innerHTML = listNames
          .map((name) => {
            const list = savedLists[name];
            const date = new Date(list.timestamp).toLocaleDateString();
            return `
            <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: #0f172a; border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 8px; margin-bottom: 8px;">
              <div style="flex: 1; min-width: 0;">
                <div style="font-weight: 500; font-size: 13px; color: var(--text); margin-bottom: 2px;">${name}</div>
                <div style="font-size: 11px; color: var(--muted);">
                  ${list.targets ? list.targets.join(", ") : list.target} (${list.combinedPrereqs ? list.combinedPrereqs.length : list.prerequisites.length} prereqs) • ${date}
                </div>
              </div>
              <button onclick="loadList('${name}')" style="padding: 4px 8px; border-radius: 4px; border: 1px solid var(--accent); background: transparent; color: var(--accent); font-size: 11px; cursor: pointer;">Load</button>
              <button onclick="renameList('${name}')" style="padding: 4px 8px; border-radius: 4px; border: 1px solid var(--muted); background: transparent; color: var(--muted); font-size: 11px; cursor: pointer;">Rename</button>
              <button onclick="deleteList('${name}')" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #f87171; background: transparent; color: #f87171; font-size: 11px; cursor: pointer;">Delete</button>
            </div>
          `;
          })
          .join("");
      }

      // Add enter key support for save input
      document.addEventListener("DOMContentLoaded", function () {
        const saveNameTopInput = document.getElementById("saveNameTop");

        saveNameTopInput.addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            saveCurrentListFromTop();
          }
        });
      });

      // Drag and drop functionality using SortableJS
      let sortableInstance = null;

      function initializeSortable() {
        const chainEl = document.getElementById("chain");
        if (sortableInstance) {
          sortableInstance.destroy();
        }

        sortableInstance = new Sortable(chainEl, {
          animation: 150,
          ghostClass: "sortable-ghost",
          chosenClass: "sortable-chosen",
          dragClass: "sortable-drag",
          filter: ".no-drag", // Prevent dragging the target tech arrow
          onEnd: function (evt) {
            // Auto-reorder dependent technologies after moving a prerequisite
            autoReorderDependents(evt);
          },
        });
      }

      function autoReorderDependents(evt) {
        if (!evt || !evt.item) return;

        const movedItem = evt.item.dataset.techName;
        if (!movedItem) return;

        const currentOrder = getCurrentOrder();
        if (currentOrder.length === 0) return;

        // Find the old and new positions of the moved item
        const oldIndex = parseInt(evt.oldIndex);
        const newIndex = parseInt(evt.newIndex);

        console.log(`Item ${movedItem} moved from position ${oldIndex} to position ${newIndex}`);

        let newOrder;
        if (newIndex > oldIndex) {
          // Moved further back - bring dependents behind it
          console.log("Moving item further back - bringing dependents behind it");
          newOrder = moveDependentsBehind(currentOrder, movedItem, newIndex);
        } else {
          // Moved earlier - bring dependencies before it
          console.log("Moving item earlier - bringing dependencies before it");
          newOrder = moveDependenciesBefore(currentOrder, movedItem, newIndex);
        }

        if (JSON.stringify(newOrder) !== JSON.stringify(currentOrder)) {
          console.log("Auto-reordering to fix dependency violations:", {
            movedItem,
            oldIndex,
            newIndex,
            oldOrder: currentOrder,
            newOrder,
          });
          renderCustomOrder(newOrder, true); // Animate the reordering
          // Update validation status after reordering animation completes
          setTimeout(() => {
            updateValidationStatus();
          }, 300); // Wait for animation to complete
        } else {
          console.log("No dependency violations found, order is valid");
          // Update validation status immediately if no reordering was needed
          updateValidationStatus();
        }
      }

      function moveDependentsBehind(order, movedItem, newIndex) {
        // Find all technologies that depend on the moved item (directly or indirectly)
        const dependents = new Set();

        function findDependents(prereq) {
          for (let i = 0; i < order.length; i++) {
            const tech = order[i];
            const prereqs = advances[tech]?.prereqs || [];

            if (prereqs.includes(prereq)) {
              dependents.add(tech);
              findDependents(tech); // Recursively find dependents of dependents
            }
          }
        }

        findDependents(movedItem);

        if (dependents.size === 0) {
          console.log(`${movedItem} has no dependents, no reordering needed`);
          return order;
        }

        console.log(`Found dependents of ${movedItem}:`, Array.from(dependents));

        // Create new order with dependents moved after the moved item
        const newOrder = [];
        const dependentsArray = Array.from(dependents);

        // Add items before the moved item
        for (let i = 0; i < newIndex; i++) {
          if (!dependents.has(order[i])) {
            newOrder.push(order[i]);
          }
        }

        // Add the moved item
        newOrder.push(movedItem);

        // Add all dependents in dependency order
        const orderedDependents = orderDependentsByDependency(dependentsArray);
        for (const dependent of orderedDependents) {
          newOrder.push(dependent);
        }

        // Add remaining items (excluding the moved item and its dependents)
        for (let i = newIndex + 1; i < order.length; i++) {
          if (!dependents.has(order[i])) {
            newOrder.push(order[i]);
          }
        }

        // Ensure all targets are included at the end if they're not already in the order
        selectedTargets.forEach((target) => {
          if (!newOrder.includes(target)) {
            newOrder.push(target);
          }
        });

        return newOrder;
      }

      function moveDependenciesBefore(order, movedItem, newIndex) {
        // Find all dependencies of the moved item that come after it
        const dependenciesAfter = [];
        const movedItemPrereqs = advances[movedItem]?.prereqs || [];

        for (const prereq of movedItemPrereqs) {
          const prereqIndex = order.indexOf(prereq);
          if (prereqIndex > newIndex) {
            dependenciesAfter.push(prereq);
          }
        }

        if (dependenciesAfter.length === 0) {
          console.log(`${movedItem} has no dependencies after its new position, no reordering needed`);
          return order;
        }

        console.log(`Found dependencies of ${movedItem} that need to be moved:`, dependenciesAfter);

        // Recursively find all dependencies that need to be moved
        const allDependenciesToMove = new Set();

        function addDependencyAndItsDependencies(tech) {
          allDependenciesToMove.add(tech);
          const techPrereqs = advances[tech]?.prereqs || [];

          for (const prereq of techPrereqs) {
            const prereqIndex = order.indexOf(prereq);
            if (prereqIndex > newIndex) {
              addDependencyAndItsDependencies(prereq);
            }
          }
        }

        for (const dependency of dependenciesAfter) {
          addDependencyAndItsDependencies(dependency);
        }

        // Create new order with dependencies moved before the moved item
        const newOrder = [];
        const dependenciesArray = Array.from(allDependenciesToMove);

        // Add items before the new position that aren't being moved
        for (let i = 0; i < newIndex; i++) {
          if (!allDependenciesToMove.has(order[i])) {
            newOrder.push(order[i]);
          }
        }

        // Add all dependencies in dependency order
        const orderedDependencies = orderDependentsByDependency(dependenciesArray);
        for (const dependency of orderedDependencies) {
          newOrder.push(dependency);
        }

        // Add the moved item
        newOrder.push(movedItem);

        // Add remaining items (excluding the moved item and its dependencies)
        for (let i = newIndex + 1; i < order.length; i++) {
          if (!allDependenciesToMove.has(order[i])) {
            newOrder.push(order[i]);
          }
        }

        // Ensure all targets are included at the end if they're not already in the order
        selectedTargets.forEach((target) => {
          if (!newOrder.includes(target)) {
            newOrder.push(target);
          }
        });

        return newOrder;
      }

      function orderDependentsByDependency(dependents) {
        // Sort dependents so that prerequisites come before their dependents
        const sorted = [];
        const added = new Set();

        function addWithPrereqs(tech) {
          if (added.has(tech)) return;

          const prereqs = advances[tech]?.prereqs || [];
          for (const prereq of prereqs) {
            if (dependents.includes(prereq)) {
              addWithPrereqs(prereq);
            }
          }

          sorted.push(tech);
          added.add(tech);
        }

        for (const tech of dependents) {
          addWithPrereqs(tech);
        }

        return sorted;
      }

      function updateValidationStatus() {
        if (selectedTargets.size === 0) return;

        const currentOrder = getCurrentOrder();

        // Get combined prerequisites for all targets
        const combinedPrereqs = getCombinedPrerequisites();
        const missingPrereqs = combinedPrereqs.filter((prereq) => !currentOrder.includes(prereq));

        // Check for prerequisite ordering issues
        const orderingIssues = [];
        for (let i = 0; i < currentOrder.length; i++) {
          const tech = currentOrder[i];
          const prereqs = advances[tech]?.prereqs || [];

          for (const prereq of prereqs) {
            const prereqIndex = currentOrder.indexOf(prereq);
            if (prereqIndex > i) {
              // Prerequisite comes after the technology that needs it
              orderingIssues.push(`${tech} requires ${prereq} to come first`);
            }
          }
        }

        console.log("Validation debug:", {
          currentOrder,
          combinedPrereqs,
          missingPrereqs,
          orderingIssues,
          selectedTargets: Array.from(selectedTargets),
        });

        // Debug: Show exactly what the ordering issues are
        if (orderingIssues.length > 0) {
          console.log("Ordering issues details:", orderingIssues);
        }

        if (missingPrereqs.length > 0) {
          notesEl.innerHTML = `<span style="color: #fbbf24;">⚠️ Warning: Missing prerequisites: ${missingPrereqs.join(", ")}. Drag them back into the list or use Reset Order.</span>`;
        } else if (orderingIssues.length > 0) {
          notesEl.innerHTML = `<span style="color: #fbbf24;">⚠️ Warning: Prerequisite order issues: ${orderingIssues.join(", ")}. Reorder technologies or use Reset Order.</span>`;
        } else {
          notesEl.innerHTML = `✅ Valid research path.`;
        }
      }

      function getCurrentOrder() {
        const chainEl = document.getElementById("chain");
        const listItems = chainEl.children;

        console.log("getCurrentOrder debug:", {
          totalItems: listItems.length,
          items: Array.from(listItems).map((item, index) => ({
            index,
            text: item.textContent,
            dataset: item.dataset.techName,
            isTarget: item.dataset.isTarget,
            html: item.outerHTML,
            className: item.className,
            style: item.style.cssText,
          })),
        });

        const result = Array.from(listItems)
          .filter((item) => !item.classList.contains("no-drag"))
          .map((item, index) => {
            // Try to get from dataset first, fall back to strong tag extraction
            if (item.dataset.techName) {
              console.log(`Item ${index}: Using dataset.techName = "${item.dataset.techName}"`);
              return item.dataset.techName;
            }
            // Extract from strong tag (same logic as in render function)
            const strongElement = item.querySelector("strong");
            if (strongElement) {
              const extracted = strongElement.textContent.trim();
              console.log(`Item ${index}: Extracted from strong tag = "${extracted}"`);
              return extracted;
            }
            console.log(`Item ${index}: No tech name found`);
            return null;
          })
          .filter((name) => name && advances[name]); // Only include valid technology names

        console.log("Final getCurrentOrder result:", result);
        return result;
      }

      function ensurePrerequisiteIntegrity(order) {
        const currentTech = techSelect.value;
        if (!currentTech) return order;

        // Get all prerequisites needed for the target technology
        const targetPrereqs = prerequisiteChain(currentTech);
        const targetPrereqsSet = new Set(targetPrereqs);

        const validatedOrder = [];
        const added = new Set();

        // First, ensure all target prerequisites are included
        for (const prereq of targetPrereqs) {
          if (!added.has(prereq)) {
            validatedOrder.push(prereq);
            added.add(prereq);
          }
        }

        // Then add any additional technologies from the custom order
        for (const tech of order) {
          if (!added.has(tech)) {
            validatedOrder.push(tech);
            added.add(tech);
          }
        }

        return validatedOrder;
      }

      function renderCustomOrder(order, animate = false) {
        const chainEl = document.getElementById("chain");

        if (!animate) {
          // Direct render without animation
          chainEl.innerHTML = "";

          order.forEach((tech, index) => {
            const li = document.createElement("li");
            li.dataset.techName = tech;
            li.style.cursor = "grab";

            // Check if this is a target technology
            const isTarget = selectedTargets.has(tech);
            const displayName = isTarget ? `→ ${tech}` : tech;
            const className = isTarget ? "accent" : "";

            // Add allows information with color coding
            const techAllows = getTechnologyAllows(tech);
            let allowsHtml = "";
            let allowsChips = [];

            Object.entries(techAllows).forEach(([category, items]) => {
              if (items.length > 0) {
                items.forEach((item) => {
                  const cssClass = category === "units" ? "unit" : category === "buildings" ? "building" : category === "wonders" ? "wonder" : "other";
                  allowsChips.push(`<span class="allows-chip allows-${cssClass}">${item}</span>`);
                });
              }
            });

            if (allowsChips.length > 0) {
              allowsHtml = allowsChips.join("");
            }

            li.innerHTML = `<strong class="${className}">${displayName}</strong>${allowsHtml}`;

            // Set target attributes if this is a target
            if (isTarget) {
              li.dataset.isTarget = "true";
            }

            chainEl.appendChild(li);
          });

          // Add target techs at the end (only if they're not already in the order)
          selectedTargets.forEach((target) => {
            if (!order.includes(target)) {
              const final = document.createElement("li");
              final.innerHTML = `<strong class="accent">→ ${target}</strong>`;
              final.style.cursor = "grab";
              final.dataset.techName = target;
              final.dataset.isTarget = "true";
              chainEl.appendChild(final);
            }
          });

          // Re-initialize SortableJS
          initializeSortable();
          // Update validation status after rendering
          updateValidationStatus();
          return;
        }

        // Animate existing elements moving to new positions
        const currentItems = Array.from(chainEl.querySelectorAll("li:not(.no-drag)"));
        const currentOrder = currentItems.map((item) => item.dataset.techName);

        // If orders are the same, no animation needed
        if (JSON.stringify(currentOrder) === JSON.stringify(order)) {
          return;
        }

        // Create a map of current positions
        const currentPositions = {};
        currentItems.forEach((item, index) => {
          currentPositions[item.dataset.techName] = index;
        });

        // Create a map of new positions
        const newPositions = {};
        order.forEach((tech, index) => {
          newPositions[tech] = index;
        });

        // Update styling for existing items that are targets
        currentItems.forEach((item) => {
          const techName = item.dataset.techName;
          if (selectedTargets.has(techName)) {
            // Update the display to show it's a target
            const strongElement = item.querySelector("strong");
            if (strongElement) {
              strongElement.textContent = `→ ${techName}`;
              strongElement.className = "accent";
            }
            item.dataset.isTarget = "true";
          }
        });

        // Add target techs at the end (only if they're not already in the order)
        selectedTargets.forEach((target) => {
          if (!order.includes(target)) {
            const final = document.createElement("li");
            final.innerHTML = `<strong class="accent">→ ${target}</strong>`;
            final.style.cursor = "grab";
            final.dataset.techName = target;
            final.dataset.isTarget = "true";
            chainEl.appendChild(final);
          }
        });

        // Enable animations on all items
        currentItems.forEach((item) => {
          item.style.transition = "transform 0.5s ease";
        });

        // Animate each item to its new position
        currentItems.forEach((item, index) => {
          const techName = item.dataset.techName;
          const oldPosition = currentPositions[techName];
          const newPosition = newPositions[techName];

          if (oldPosition !== newPosition) {
            console.log(`${techName} moving from position ${oldPosition} to position ${newPosition}`);

            // Calculate the transform needed
            const itemHeight = item.offsetHeight + 8; // Include margin
            const deltaY = (newPosition - oldPosition) * itemHeight;

            // Apply the transform
            item.style.transform = `translateY(${deltaY}px)`;

            // After animation completes, update the DOM order
            setTimeout(() => {
              item.style.transition = "none";
              item.style.transform = "";

              // Move the item to its correct position in the DOM
              const targetIndex = newPosition;
              if (targetIndex < chainEl.children.length) {
                chainEl.insertBefore(item, chainEl.children[targetIndex]);
              } else {
                chainEl.appendChild(item);
              }
            }, 500);
          }
        });

        // Re-initialize SortableJS after all animations complete
        setTimeout(() => {
          initializeSortable();
          // Update validation status after reordering is complete
          updateValidationStatus();
        }, 600);
      }

      function resetToOriginalOrder() {
        if (selectedTargets.size > 0) {
          renderMultiTargetChain(); // This will restore the original prerequisite order
        }
      }

      // Update the save function to include custom order
      function saveCurrentListFromTop() {
        const nameInput = document.getElementById("saveNameTop");
        const name = nameInput.value.trim();

        if (!name) {
          alert("Please enter a name for your list");
          return;
        }

        if (selectedTargets.size === 0) {
          alert("Please add at least one target technology first");
          return;
        }

        const targets = Array.from(selectedTargets);
        const combinedPrereqs = getCombinedPrerequisites();
        const customOrder = getCurrentOrder();

        // Validate the custom order and show warning if invalid
        const missingPrereqs = combinedPrereqs.filter((prereq) => !customOrder.includes(prereq));

        if (missingPrereqs.length > 0) {
          const warning = `Warning: Your custom order is missing some prerequisites: ${missingPrereqs.join(", ")}. These will be automatically added when you research this path.`;
          if (!confirm(warning + "\n\nDo you want to save anyway?")) {
            return;
          }
        }

        const savedLists = getSavedLists();

        savedLists[name] = {
          targets: targets,
          combinedPrereqs: combinedPrereqs,
          customOrder: customOrder.length > 0 ? customOrder : null,
          timestamp: Date.now(),
        };

        saveLists(savedLists);
        nameInput.value = "";
        renderSavedLists();

        // Show success message
        const saveBtn = document.getElementById("saveBtnTop");
        const originalText = saveBtn.textContent;
        saveBtn.textContent = "Saved!";
        saveBtn.style.background = "#34d399";
        setTimeout(() => {
          saveBtn.textContent = originalText;
          saveBtn.style.background = "var(--accent)";
        }, 1500);
      }

      // Update the load function to restore custom order
      function loadList(name) {
        const savedLists = getSavedLists();
        const list = savedLists[name];

        if (list && (list.target || list.targets)) {
          // Handle both old single-target and new multi-target formats
          if (list.targets) {
            // Multi-target format
            selectedTargets = new Set(list.targets);
            updateMultiTargetUI();
            renderMultiTargetChain();
          } else {
            // Single-target format (backward compatibility)
            selectedTargets = new Set([list.target]);
            updateMultiTargetUI();
            renderMultiTargetChain();
          }

          // Restore custom order if it exists
          if (list.customOrder && list.customOrder.length > 0) {
            setTimeout(() => {
              renderCustomOrder(list.customOrder);
            }, 100);
          }

          // Show a brief success message
          const loadBtn = event.target;
          const originalText = loadBtn.textContent;
          loadBtn.textContent = "Loaded!";
          loadBtn.style.background = "var(--accent)";
          loadBtn.style.color = "#000";
          setTimeout(() => {
            loadBtn.textContent = originalText;
            loadBtn.style.background = "transparent";
            loadBtn.style.color = "var(--accent)";
          }, 1000);
        }
      }

      // Initialise
      render();
      renderSavedLists();
    </script>
  </body>
</html>
